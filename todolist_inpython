import tkinter as tk
from tkinter import messagebox, simpledialog
import json
import os
from datetime import datetime

TODO_FILE = "todo_list.json"

# ------------------ Task Persistence ------------------ #
def load_tasks():
    if os.path.exists(TODO_FILE):
        with open(TODO_FILE, "r") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def save_tasks():
    with open(TODO_FILE, "w") as f:
        json.dump(tasks, f, indent=4)

# ------------------ Config ------------------ #
PRIORITY_COLOR = {"High": "red", "Medium": "orange", "Low": "green"}

# ------------------ Listbox Refresh ------------------ #
def refresh_listbox(filter_type="all"):
    listbox.delete(0, tk.END)
    for idx, task in enumerate(tasks):
        if filter_type == "pending" and task["done"]:
            continue
        if filter_type == "completed" and not task["done"]:
            continue
        status = "✅" if task["done"] else "❌"
        priority = task.get("priority", "Medium")
        due = task.get("due_date", "N/A")
        listbox.insert(tk.END, f"{idx+1}. {task['title']} [{status}] - Priority: {priority} - Due: {due}")
        listbox.itemconfig(tk.END, {'fg': PRIORITY_COLOR.get(priority, "black")})

# ------------------ Task Operations ------------------ #
def add_task():
    title = simpledialog.askstring("Task Title", "Enter task title:")
    if not title:
        return

    priority = simpledialog.askstring("Priority", "Enter priority (High/Medium/Low):", initialvalue="Medium")
    if priority not in PRIORITY_COLOR:
        priority = "Medium"

    due_date = simpledialog.askstring("Due Date", "Enter due date (YYYY-MM-DD) or leave blank:", initialvalue="")
    if due_date:
        try:
            datetime.strptime(due_date, "%Y-%m-%d")
        except ValueError:
            messagebox.showwarning("Warning", "Invalid date format. Using N/A.")
            due_date = "N/A"
    else:
        due_date = "N/A"

    tasks.append({"title": title, "done": False, "priority": priority, "due_date": due_date})
    refresh_listbox()

def delete_task():
    idx = get_selected_index()
    if idx is not None:
        task = tasks.pop(idx)
        refresh_listbox()
        messagebox.showinfo("Deleted", f"Task '{task['title']}' deleted!")

def toggle_done():
    idx = get_selected_index()
    if idx is not None:
        tasks[idx]["done"] = not tasks[idx]["done"]
        refresh_listbox()

def edit_task():
    idx = get_selected_index()
    if idx is None: return
    task = tasks[idx]

    new_title = simpledialog.askstring("Edit Title", f"Edit title (current: {task['title']}):")
    if new_title: task["title"] = new_title

    new_priority = simpledialog.askstring("Edit Priority", f"Edit priority (High/Medium/Low, current: {task['priority']}):")
    if new_priority in PRIORITY_COLOR: task["priority"] = new_priority

    new_due = simpledialog.askstring("Edit Due Date", f"Edit due date (YYYY-MM-DD, current: {task['due_date']}):")
    if new_due:
        try:
            datetime.strptime(new_due, "%Y-%m-%d")
            task["due_date"] = new_due
        except ValueError:
            messagebox.showwarning("Warning", "Invalid date format. Keeping old date.")

    refresh_listbox()

def clear_all_tasks():
    if messagebox.askyesno("Clear All", "Are you sure you want to delete ALL tasks?"):
        tasks.clear()
        refresh_listbox()

def search_task():
    keyword = simpledialog.askstring("Search Task", "Enter keyword to search:")
    if not keyword:
        return
    listbox.delete(0, tk.END)
    for idx, task in enumerate(tasks):
        if keyword.lower() in task["title"].lower():
            status = "✅" if task["done"] else "❌"
            priority = task.get("priority", "Medium")
            due = task.get("due_date", "N/A")
            listbox.insert(tk.END, f"{idx+1}. {task['title']} [{status}] - Priority: {priority} - Due: {due}")
            listbox.itemconfig(tk.END, {'fg': PRIORITY_COLOR.get(priority, "black")})

# ------------------ Drag & Drop ------------------ #
def on_start_drag(event):
    event.widget.start_index = event.widget.nearest(event.y)

def on_drag_motion(event):
    widget = event.widget
    i = widget.nearest(event.y)
    if i != widget.start_index:
        tasks[i], tasks[widget.start_index] = tasks[widget.start_index], tasks[i]
        widget.start_index = i
        refresh_listbox()

# ------------------ Helper ------------------ #
def get_selected_index():
    selection = listbox.curselection()
    if not selection: return None
    return selection[0]

# ------------------ Initialize ------------------ #
tasks = load_tasks()
root = tk.Tk()
root.title("Advanced To-Do Manager with Drag-and-Drop")
root.geometry("750x500")

# Listbox
listbox = tk.Listbox(root, width=100, height=20, font=("Arial", 12))
listbox.pack(pady=10)
listbox.bind("<Button-1>", on_start_drag)
listbox.bind("<B1-Motion>", on_drag_motion)

# Buttons Frame
frame = tk.Frame(root)
frame.pack(pady=5)

buttons = [
    ("Add Task", add_task), ("Delete Task", delete_task), ("Mark Done/Undone", toggle_done),
    ("Edit Task", edit_task), ("Clear All", clear_all_tasks), ("Search Task", search_task),
    ("Show All", lambda: refresh_listbox("all")), ("Show Pending", lambda: refresh_listbox("pending")),
    ("Show Completed", lambda: refresh_listbox("completed")), ("Save & Exit", lambda: [save_tasks(), root.destroy()])
]

for i, (text, cmd) in enumerate(buttons):
    tk.Button(frame, text=text, command=cmd, width=15).grid(row=i//5, column=i%5, padx=5, pady=5)

refresh_listbox()
root.mainloop()
